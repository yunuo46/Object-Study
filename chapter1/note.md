## 프롤로그

과학 패러다임은 혁명적(revolutionary)이다.

프로그래밍 패러다임은 발전적(evolutionary)이다.

따라서, 객체지향을 사용하더라도 다른 방법론을 공부하는 것이 도움이 된다



## 1장

소프트웨어 분야는 실무가 이론보다 우선이다.

이론을 정립할 수 없는 초기의 학문이기 때문

이론보다는 ‘코드’ 그 자체가 더 중요함

### 티켓 판매 애플리케이션


### 문제1

관람객과 판매원이 수동적임

→ 객체의 자율성이 없음

### 문제2

변경에 취약함

만약 현금이 아닌 카드 결제를 도입한다면?

의존성 자체는 필요하지만, **불필요한 의존성을 제거**해야함

→ 결합도를 낮춰야함

### 해결1

Theater가 관람객과 판매원에 대해 너무 많은 걸 알고 있음

입장만 시키면 끝!

다시 말해 관람객과 판매원을 자율적인 존재로 만들자

Theater에 있던 로직을 tickerSeller의 sellTo 메서드로 옮김

자연스럽게 getTicketOffice 메서드는 삭제된다

→ Theater는 ticketOffice에 접근할 수 없음

→ 캡슐화

Theater는 오직 tickerSeller의 인터페이스에만 의존


### 해결2

관람객(Audience)는 여전히 자율적인 존재가 아니다

getBag메서드를 없애자

bag를 접근하는 코드를 Audience에 buy 메서드로 옮기면된다

> 변경된 코드에서 Audience는 자신의 가방 안에 초대장이 들어있는지를 스스로 확인한다. 외부의 제3자가 자신의 가방을 열어보도록 허용하지 않는다. Audience가 Bag을 직접 처리하기 때문에 외부에서는 더이상 Audience가 Bag을 소유하고 있다는 사실을 알 필요가 없다. 이제 Audience 클래스에서 getBag 메서드를 제거할 수 있고 결과적으로 Bag의 존재를 내부로 캡슐화할 수 있게 됐다.
>


## 중간 점검

이제 Audience가 가방이 아닌 작은 지갑을 소지하던가, TicketSeller가 매표소가 아닌 은행에 돈을 보관하게 하도록 하려면 해당 객체의 내부만 변경하면 된다!

이렇게 메세지를 통해서만 상호작용하도록 하면 객체끼리는 서로의 내부에 대해서는 알지 못한다. 객체에 밀접한 작업만을 수행하고 다른 작업은 다른 객체에게 위임한다.

→ 응집도가 높다

→ 객체 스스로 자신의 데이터를 책임진다.

> 이 관점에서 Theater의 enter 메서드는 프로세스(Process)이며 Audience, Ticketseller, Bag,Ticketoffice는 데이터(Data)다. 이처럼 프로세스와 데이터를 별도의 모듈에 위치시키는 방식을 **절차적 프로그래밍 (Procedural Programming)** 이 라고 부른다.
>
> 사실 그림 1.2는 절차적 프로그래밍 방식으로 작성된 코드의 전형적인 의존성 구조를 보여준다. 프로세스를 담당하는 Theater가 Ticketseller, Ticketoffice, Audience, Bag 모두에 의존하고 있음에 주목하라.  이것은 모든 처리가 하나의 클래스 안에 위치하고 나머지 클래스는 단지 데이터의 역할만 수행하기 때문이다
>
> …
>
>
> 데이터와 프로세스가 동일한 모듈 내부에 위치하도록 프로그래밍하는 방식을 **객체지향 프로그래밍(Object-Oriented Programming)**이라고 부른다.
>

즉, 절차적 프로그래밍은 우리의 직관에 위배된다. 절차적 프로그래밍에서는 관람객과 판매원이 수동적이다.

객체지향 안에는 단순히 데이터와 프로세스를 하나의 객체 안으로 모으는 것 이상의
무엇이 있다!!!

→ 객체가 어떤 데이터를 가지느냐보다는 어떤 책임을 가질 것인 지, 각 객체가 어떻게 협력할 것인지 등

## 또 다른 문제

Bag를 자율적으로 바꾸자

Bag에 hold 메서드를 추가하여 가방 안의 티켓을 꺼내는 행위를 옮겼다

TicketOffice도 자율적으로 바꿔보자

SellTicketTo 메서드를 추가하여 티켓을 판매하는 행위를 TicketOffice로 옮겼다

그리고 이제 TicketSeller는 TicketOffice의 구현이 아닌 인터페이스에만 의존한다

→ 하지만, TicketOffice와 Audience 사이에 의존성이 추가됐다…

→ 즉, TicketOffice가 Audience에게 직접 티켓을 판매하게 된다

**TicketOffice의 자율성은 높였지만, 의존성이 추가되고 전체 설계의 결합도가 상승했다!!**

트레이드 오프!

→ 결론은 좌측이 좀 더 중요하다

### 결론

1. 동일한 기능을 한가지 이상의 방법으로 설계할 수 있다.
2. 결국 설계는 트레이드 오프

## 모두가 자율적인 존재는 아니다

Bag와 TicketOffice는 현실에서는 자율적인 존재가 아니다.

가방에서 돈을 꺼내는 건 관람객이지 가방이 아니며, 티켓을 파는 건 판매원이지 판매소가 아니다. 즉, 우리는 무생물 또한 자율적이고 책임을 갖는 존재로 취급한 것이다.

이렇듯 현실과는 다르게 코드에서는 모든 것이 능동적이고 자율적인 존재로 바뀔 수 있다.

> 레베카 워프스버-록(Rebecca Wirfs-Brock)은 이처럼 능동적이고 자율적인 존재로 소프트웨어 객체를 설계하는 원칙을 가리켜 의인화｛anthropomorphism)라고 부른다
>
>
> 훌륭한 객체지향 설계란 소프트웨어를 구성하는 모든 객체들이 자율적으로 행동하는 설계를 가리킨다. 그 대상이 비록 실세계에서는 생명이 없는 수동적인 존재라고 하더라도 객체지향의 세계로 넘어오는 순간 그들은 생명과 지능을 가진 싱싱한 존재로 다시 태어난다
>
> …
>
> 훌륭한 객체지향 설계란 협력하는 객체 사이의 의존성을 적절하게 관리하는 설계다. (…) 데이터와 프로세스를 하나의 덩어리로 모으는 것은 훌륭한 객체지향 설계로 가는 첫걸음일 뿐이다. 진정한 객체지향 설계로 나아가는 길은 협력하는 객체들 사이의 의존성을 적절하게 조절함으로써 변경에 용이한 설계를 만드는 것이다.
>