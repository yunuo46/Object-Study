객체지향에서 가장 중요한 것은 **협력, 책임, 역할**

협력 = 객체들이 애플리케이션의 기능을 구현하기 위해 수행하는 상호작용

책임 = 객체가 협력에 참여하기 위해 수행하는 로직

역할 = 객체들이 협력 안에서 수행하는 책임들의 집합

</br>

## 협력

메세지는 협력을 위해 사용할 수 있는 유일한 수단

협력(상호작용)을 통해 더 큰 책임을 수행할 수 있다!!

메세지를 수신한 객체는 메서드를 실행한다

→ 객체가 메세지를 처리할 방법을 스스로 선택한다(자율성)

### 협력이 설계를 위한 문맥을 결정한다

어떤 객체도 섬이 아니다. 객체가 필요하다면 그 객체가 협력에 참여하고 있기 때문이다

→ 객체의 행동을 결정하는 것은 객체가 참여하는 협력이다

객체의 상태는 그 객체가 행동을 수행하는데 필요한 정보에 따라 결정된다.

→ 객체의 상태를 결정하는 것은 행동이다

결과적으로, 협력은 객체의 행동과 상태 모두를 결정한다

= 문맥(context)를 결정한다

</br>

## 책임

객체의 책임은 크게 하는 것/아는 것

책임 > 메세지

책임은 여러 개의 메세지로 분할되거나, 하나의 객체가 수행할 수 있다고 생각했던 책임이 여러 객체가 협력해야만 하는 커다란 책임으로 자라는 것이 일반적이다

객체지향 설계에서 가장 중요한 것은 책임

→ 객체에게 얼마나 적절한 책임을 할당하느냐가 품질을 결정

information expert(정보 전문가) 패턴 = 책임을 수행하는 데 필요한 정보를 가장 잘 알고 있는 전문가에게 책임을 할당하는 것

다만, 어떤 경우에는 응집도와 결합도의 관점에서 정보 전문가가 아닌 다른 객체에게 책임을 할당하는 것이 더 적절한 경우도 있다.

책임 할당의 과정

→ 시스템이 제공하는 기능을 하나의 책임으로 본 뒤, 작은 책임들로 분할하여 할당하는 과정을 반복

= 책임 주도 설계(RDD)

</br>

### 메세지가 객체를 결정한다

객체가 메세지를 선택하는 것이 아니라, 메세지가 객체를 선택해야한다

이유로는

1. 최소한의 인터페이스를 가질 수 있다
    1. 메세지가 식별될 때까지 퍼블릭 인터페이스에 어떤 것도 추가하지 않기 때문
2. 추상적인 인터페이스를 가질 수 있다
    1. 메세지는 무엇(what)을 하는 지 의미하기 때문에, 메세지에 초점을 맞추면 객체가 어떻게(how) 수행하는 지 노출하지 않을 수 있다

결국 중요한 건 객체의 상태가 아니라 행동이다. 상태에 초점을 맞추면 캡슐화가 깨지기 쉽다. 구현에 대한 결정을 미루고 객체의 행동을 고려하자!

</br>

## 역할

역할은 유연하고 재사용 가능한 협력을 위해 필요하다

= 추상화

협력 → 역할 → 객체 → 클래스

다양한 객체들이 협력에 참여하는 것이 확실하면 역할로 시작하라

다만, 애매하다면 처음에는 구체적인 객체로 시작하고, 반복적으로 책임과 협력을 정제하면서 필요한 순간에 역할을 분리하는 것이 좋다!

역할을 통한 추상화는 상위 수준에서 협력을 설명할 수 있게한다

→ 세부적인 사항들을 제외하고 단순화해서 전체적인 그림을 파악할 수 있다

역할은 객체의 페르소나다!
